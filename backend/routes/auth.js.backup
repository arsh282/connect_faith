const express = require('express');
const { body, validationResult } = require('express-validator');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const auth = require('../middleware/auth');
const roleAuth = require('../middleware/roleAuth');

const router = express.Router();

// @route   POST /api/auth/register
// @desc    Register a new user
// @access  Public
router.post('/register', [
  // Required fields validation
  body('email', 'Please include a valid email')
    .isEmail()
    .normalizeEmail()
    .isLength({ max: 254 }),
  body('password', 'Password is required')
    .isLength({ min: 8, max: 128 })
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?])/, 'Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character'),
  body('firstName', 'First name is required').notEmpty().trim().isLength({ min: 1, max: 50 }),
  body('lastName', 'Last name is required').notEmpty().trim().isLength({ min: 1, max: 50 }),
  body('dateOfBirth', 'Date of birth is required').isISO8601().toDate(),
  
  // Address validation
  body('address.street1', 'Street address is required').notEmpty().trim().isLength({ min: 1, max: 100 }),
  body('address.city', 'City is required').notEmpty().trim().isLength({ min: 1, max: 50 }),
  body('address.region', 'Region/State is required').notEmpty().trim().isLength({ min: 1, max: 50 }),
  body('address.postalCode', 'Postal code is required').notEmpty().trim().isLength({ min: 1, max: 20 }),
  body('address.country', 'Country is required').notEmpty().trim().isLength({ min: 1, max: 50 }),
  
  // Zone validation
  body('zone', 'Zone is required').isIn(['Zone A', 'Zone B', 'Zone C', 'Zone D', 'Zone E']),
  
  // Optional fields validation
  body('middleName').optional().trim().isLength({ max: 50 }),
  body('phoneNumber').optional().trim().isLength({ max: 20 }),
  body('address.street2').optional().trim().isLength({ max: 100 })
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed',
        errors: errors.array() 
      });
    }

    const { 
      email, 
      password, 
      firstName, 
      lastName, 
      middleName,
      phoneNumber,
      dateOfBirth,
      address,
      zone
    } = req.body;

    // Prevent admin email registration
    if (email.endsWith('@admin.connectfaith.com')) {
      return res.status(400).json({ 
        success: false,
        message: 'Admin emails cannot be registered through this form' 
      });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) {
      return res.status(400).json({ 
        success: false,
        message: 'User already exists with this email address' 
      });
    }

    // Create new user with all fields
    const user = new User({
      email: email.toLowerCase(),
      password,
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      middleName: middleName ? middleName.trim() : undefined,
      phoneNumber: phoneNumber ? phoneNumber.trim() : undefined,
      dateOfBirth: new Date(dateOfBirth),
      address: {
        street1: address.street1.trim(),
        street2: address.street2 ? address.street2.trim() : undefined,
        city: address.city.trim(),
        region: address.region.trim(),
        postalCode: address.postalCode.trim(),
        country: address.country.trim()
      },
      zone: zone.trim(),
      role: 'user'
    });

    await user.save();

    // Create JWT token
    const payload = {
      user: {
        id: user._id,
        email: user.email,
        role: user.role
      }
    };

    jwt.sign(
      payload,
      process.env.JWT_SECRET,
      { expiresIn: '7d' },
      (err, token) => {
        if (err) throw err;
        res.status(201).json({
          success: true,
          message: 'User registered successfully',
          token,
          user: {
            id: user._id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            middleName: user.middleName,
            fullName: user.fullName,
            phoneNumber: user.phoneNumber,
            dateOfBirth: user.dateOfBirth,
            address: user.address,
            zone: user.zone,
            role: user.role,
            isActive: user.isActive,
            createdAt: user.createdAt
          }
        });
      }
    );
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Server error during registration' 
    });
  }
});

// @route   POST /api/auth/login
// @desc    Authenticate user & get token
// @access  Public
router.post('/login', [
  body('email', 'Please include a valid email')
    .isEmail()
    .normalizeEmail(),
  body('password', 'Password is required')
    .isLength({ min: 1 })
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed',
        errors: errors.array() 
      });
    }

    const { email, password } = req.body;

    // Find user by email
    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) {
      return res.status(401).json({ 
        success: false,
        message: 'Invalid email or password' 
      });
    }

    // Check if user is active
    if (!user.isActive) {
      return res.status(401).json({ 
        success: false,
        message: 'Account is deactivated' 
      });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ 
        success: false,
        message: 'Invalid email or password' 
      });
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save();

    // Create JWT token
    const payload = {
      user: {
        id: user._id,
        email: user.email,
        role: user.role
      }
    };

    jwt.sign(
      payload,
      process.env.JWT_SECRET,
      { expiresIn: '7d' },
      (err, token) => {
        if (err) throw err;
        res.json({
          success: true,
          message: 'Login successful',
          token,
          user: {
            id: user._id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            middleName: user.middleName,
            fullName: user.fullName,
            phoneNumber: user.phoneNumber,
            dateOfBirth: user.dateOfBirth,
            address: user.address,
            zone: user.zone,
            role: user.role,
            isActive: user.isActive,
            lastLogin: user.lastLogin,
            createdAt: user.createdAt
          }
        });
      }
    );
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Server error during login' 
    });
  }
});

// @route   GET /api/auth/me
// @desc    Get current user
// @access  Private
router.get('/me', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) {
      return res.status(404).json({ 
        success: false,
        message: 'User not found' 
      });
    }

    res.json({
      success: true,
      user: {
        id: user._id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        middleName: user.middleName,
        fullName: user.fullName,
        phoneNumber: user.phoneNumber,
        dateOfBirth: user.dateOfBirth,
        address: user.address,
        zone: user.zone,
        role: user.role,
        isActive: user.isActive,
        lastLogin: user.lastLogin,
        createdAt: user.createdAt
      }
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Server error' 
    });
  }
});

// @route   POST /api/auth/logout
// @desc    Logout user (client-side token removal)
// @access  Private
router.post('/logout', auth, (req, res) => {
  res.json({ 
    success: true,
    message: 'Logged out successfully' 
  });
});

// @route   PUT /api/auth/profile
// @desc    Update user profile
// @access  Private
router.put('/profile', auth, [
  body('firstName', 'First name is required').optional().trim().isLength({ min: 1, max: 50 }),
  body('lastName', 'Last name is required').optional().trim().isLength({ min: 1, max: 50 }),
  body('middleName').optional().trim().isLength({ max: 50 }),
  body('phoneNumber', 'Invalid phone number').optional().trim().isLength({ max: 20 }),
  body('dateOfBirth').optional().isISO8601().toDate(),
  body('zone').optional().isIn(['Zone A', 'Zone B', 'Zone C', 'Zone D', 'Zone E']),
  body('address.street1').optional().trim().isLength({ max: 100 }),
  body('address.street2').optional().trim().isLength({ max: 100 }),
  body('address.city').optional().trim().isLength({ max: 50 }),
  body('address.region').optional().trim().isLength({ max: 50 }),
  body('address.postalCode').optional().trim().isLength({ max: 20 }),
  body('address.country').optional().trim().isLength({ max: 50 })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed',
        errors: errors.array() 
      });
    }

    const { 
      firstName, 
      lastName, 
      middleName,
      phoneNumber,
      dateOfBirth,
      address,
      zone
    } = req.body;
    
    const updateData = {};

    if (firstName) updateData.firstName = firstName.trim();
    if (lastName) updateData.lastName = lastName.trim();
    if (middleName !== undefined) updateData.middleName = middleName ? middleName.trim() : undefined;
    if (phoneNumber !== undefined) updateData.phoneNumber = phoneNumber ? phoneNumber.trim() : undefined;
    if (dateOfBirth) updateData.dateOfBirth = new Date(dateOfBirth);
    if (zone) updateData.zone = zone.trim();
    if (address) {
      updateData.address = {};
      if (address.street1) updateData.address.street1 = address.street1.trim();
      if (address.street2 !== undefined) updateData.address.street2 = address.street2 ? address.street2.trim() : undefined;
      if (address.city) updateData.address.city = address.city.trim();
      if (address.region) updateData.address.region = address.region.trim();
      if (address.postalCode) updateData.address.postalCode = address.postalCode.trim();
      if (address.country) updateData.address.country = address.country.trim();
    }

    const user = await User.findByIdAndUpdate(
      req.user.id,
      updateData,
      { new: true, runValidators: true }
    ).select('-password');

    if (!user) {
      return res.status(404).json({ 
        success: false,
        message: 'User not found' 
      });
    }

    res.json({
      success: true,
      message: 'Profile updated successfully',
      user
    });
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Server error' 
    });
  }
});

// @route   POST /api/auth/change-password
// @desc    Change user password
// @access  Private
router.post('/change-password', auth, [
  body('currentPassword', 'Current password is required').notEmpty(),
  body('newPassword', 'New password is required')
    .isLength({ min: 8, max: 128 })
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?])/, 'Password must contain at least one lowercase letter, one uppercase letter, one number, and one special character')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed',
        errors: errors.array() 
      });
    }

    const { currentPassword, newPassword } = req.body;

    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ 
        success: false,
        message: 'User not found' 
      });
    }

    // Verify current password
    const isMatch = await user.comparePassword(currentPassword);
    if (!isMatch) {
      return res.status(400).json({ 
        success: false,
        message: 'Current password is incorrect' 
      });
    }

    // Update password
    user.password = newPassword;
    await user.save();

    res.json({
      success: true,
      message: 'Password changed successfully'
    });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({ 
      success: false,
      message: 'Server error' 
    });
  }
});

module.exports = router;
